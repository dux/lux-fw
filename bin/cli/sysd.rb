SYSD_DIR = './config/sysd'

SECURITY_FILTER_CADDY = <<~CADDY
(security_filter) {
  @blocked {
    path *.php
    path /wp-*
    path /wordpress/*
    path /wp-admin/*
    path /wp-content/*
    path /wp-includes/*
    path /.env
    path /.git/*
    path /config/*
    path /phpinfo*
    path /phpmyadmin*
    path /pma/*
    path /mysql/*
    path /admin.php
    path /xmlrpc.php
    path /cgi-bin/*
    path /shell*
    path /.aws/*
    path /.ssh/*
    path /etc/passwd
    path /actuator/*
    path /api/v1/pods
  }

  handle @blocked {
    respond "not found" 404
  }
}
CADDY

SECURITY_FILTER_NGINX = <<~NGINX
# Security: block malicious paths
map $request_uri $blocked_request {
    ~*\\.php$                   1;
    ~^/wp-                      1;
    ~^/wordpress/               1;
    ~^/\\.env                   1;
    ~^/\\.git/                  1;
    ~^/config/                  1;
    ~^/phpinfo                  1;
    ~^/phpmyadmin               1;
    ~^/pma/                     1;
    ~^/mysql/                   1;
    ~^/admin\\.php              1;
    ~^/xmlrpc\\.php             1;
    ~^/cgi-bin/                 1;
    ~^/shell                    1;
    ~^/\\.aws/                  1;
    ~^/\\.ssh/                  1;
    ~^/etc/passwd               1;
    ~^/actuator/                1;
    ~^/api/v1/pods              1;
    default                     0;
}
NGINX

LuxCli.class_eval do
  desc :sysd, 'Manage systemd services and generate config files'
  def sysd(action = nil, service = nil)
    case action
    when 'generate'
      sysd_generate
    when 'tui'
      sysd_tui
    when 'list'
      sysd_list
    when 'install'
      sysd_install(service)
    when 'start'
      sysd_action('start', service)
    when 'stop'
      sysd_action('stop', service)
    when 'restart'
      sysd_action('restart', service)
    when 'log'
      sysd_log(service)
    when 'status'
      sysd_status(service)
    else
      sysd_help
    end
  end

  private

  def sysd_help
    puts <<~HELP
Lux Systemd Service Manager

Generate config files to #{SYSD_DIR}/ and manage services.

Commands:
  lux sysd generate          Generate all config files from .env
  lux sysd tui               Interactive TUI for service management
  lux sysd list              List services in #{SYSD_DIR}/
  lux sysd install [name]    Show install instructions
  lux sysd start <name>      Start service
  lux sysd stop <name>       Stop service
  lux sysd restart <name>    Restart service
  lux sysd log <name>        Follow service logs
  lux sysd status [name]     Show service status

Required .env variables:
  DOMAIN=myapp.com           Domain for reverse proxy configs
  PORT=3000                  Port or port range (e.g., 3000-3003)

Generated files:
  #{SYSD_DIR}/lux-web-{app}.service    Systemd web service
  #{SYSD_DIR}/lux-job-{app}.service    Systemd job runner service
  #{SYSD_DIR}/caddy.conf               Caddy reverse proxy config
  #{SYSD_DIR}/nginx-proxy.conf         Nginx reverse proxy config
  #{SYSD_DIR}/nginx-passenger.conf     Nginx with Passenger config
    HELP
  end

  def sysd_generate
    load_dotenv

    domain = ENV['DOMAIN']
    unless domain
      puts "Error: DOMAIN not defined in .env".red
      puts "Add DOMAIN=yourdomain.com to .env"
      exit 1
    end

    port_str = ENV.fetch('PORT', '3000')
    ports = parse_ports(port_str)
    app_name = File.basename(Dir.pwd)

    puts "Reading .env: DOMAIN=#{domain} PORT=#{port_str}"
    puts

    FileUtils.mkdir_p(SYSD_DIR)

    generated = 0
    generated += generate_web_service(app_name, domain, port_str, ports)
    generated += generate_job_service(app_name)
    generated += generate_caddy(app_name, domain, ports)
    generated += generate_nginx(app_name, domain, ports)
    generated += generate_nginx_passenger(app_name, domain)

    puts
    puts "Done. #{generated} files generated."
  end

  def generate_web_service(app_name, domain, port_str, ports)
    file = "#{SYSD_DIR}/lux-web-#{app_name}.service"
    user = ENV['USER']
    pwd = Dir.pwd
    bundle_path = `which bundle`.strip

    content = <<~SERVICE
# Lux Web Service - Generated by: lux sysd generate
# App: #{app_name} | Domain: #{domain} | Port: #{port_str}
#
# Install:
#   sudo ln -sf #{pwd}/config/sysd/lux-web-#{app_name}.service /etc/systemd/system/
#   sudo systemctl daemon-reload
#   sudo systemctl enable lux-web-#{app_name}
#   sudo systemctl start lux-web-#{app_name}

[Unit]
Description=Lux Web #{app_name} (#{domain})
After=network.target

[Service]
Type=simple
User=#{user}
WorkingDirectory=#{pwd}
ExecStart=#{bundle_path} exec lux s -p #{port_str} -e production
Restart=always
RestartSec=5
EnvironmentFile=-#{pwd}/.env

[Install]
WantedBy=multi-user.target
    SERVICE

    write_config(file, content)
  end

  def generate_job_service(app_name)
    file = "#{SYSD_DIR}/lux-job-#{app_name}.service"
    user = ENV['USER']
    pwd = Dir.pwd
    bundle_path = `which bundle`.strip

    content = <<~SERVICE
# Lux Job Runner - Generated by: lux sysd generate
# App: #{app_name}
#
# Install:
#   sudo ln -sf #{pwd}/config/sysd/lux-job-#{app_name}.service /etc/systemd/system/
#   sudo systemctl daemon-reload
#   sudo systemctl enable lux-job-#{app_name}
#   sudo systemctl start lux-job-#{app_name}

[Unit]
Description=Lux Job Runner #{app_name}
After=network.target

[Service]
Type=simple
User=#{user}
WorkingDirectory=#{pwd}
ExecStart=#{bundle_path} exec rake job_runner:start
Restart=always
RestartSec=5
EnvironmentFile=-#{pwd}/.env

[Install]
WantedBy=multi-user.target
    SERVICE

    write_config(file, content)
  end

  def generate_caddy(app_name, domain, ports)
    file = "#{SYSD_DIR}/caddy.conf"
    backends = ports.map { |p| "localhost:#{p}" }.join(' ')
    port_str = ports.size > 1 ? "#{ports.first}-#{ports.last}" : ports.first.to_s

    content = <<~CADDY
# Caddy config - Generated by: lux sysd generate
# App: #{app_name} | Domain: #{domain} | Port: #{port_str}
#
# Option 1 - Include in main Caddyfile:
#   Add this line to /etc/caddy/Caddyfile:
#     import #{Dir.pwd}/config/sysd/caddy.conf
#   sudo systemctl reload caddy
#
# Option 2 - Append to existing Caddyfile:
#   cat #{file} | sudo tee -a /etc/caddy/Caddyfile
#   sudo systemctl reload caddy
#
# Option 3 - Replace entirely (if this is your only app):
#   sudo cp #{file} /etc/caddy/Caddyfile
#   sudo systemctl reload caddy

#{SECURITY_FILTER_CADDY}
#{domain}, *.#{domain} {
  import security_filter
  reverse_proxy #{backends}
}
    CADDY

    write_config(file, content)
  end

  def generate_nginx(app_name, domain, ports)
    file = "#{SYSD_DIR}/nginx-proxy.conf"
    upstream_name = domain.gsub('.', '_').gsub('-', '_')
    backends = ports.map { |p| "    server 127.0.0.1:#{p};" }.join("\n")
    public_root = "#{Dir.pwd}/public"
    port_str = ports.size > 1 ? "#{ports.first}-#{ports.last}" : ports.first.to_s

    content = <<~NGINX
# Nginx config - Generated by: lux sysd generate
# App: #{app_name} | Domain: #{domain} | Port: #{port_str}
#
# Install:
#   sudo cp #{file} /etc/nginx/sites-available/#{app_name}
#   sudo ln -sf /etc/nginx/sites-available/#{app_name} /etc/nginx/sites-enabled/
#   sudo nginx -t && sudo systemctl reload nginx

#{SECURITY_FILTER_NGINX}
upstream #{upstream_name} {
    least_conn;
#{backends}
}

server {
    listen 80;
    server_name #{domain} *.#{domain};

    root #{public_root};

    # Block malicious requests
    if ($blocked_request) {
        return 404 "not found";
    }

    # Static file handling - try file first, then proxy
    location / {
        try_files $uri @backend;
    }

    # Assets with caching
    location ^~ /assets/ {
        gzip_static on;
        expires max;
        add_header Cache-Control public;
    }

    # Proxy to app
    location @backend {
        proxy_pass http://#{upstream_name};
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # Favicon - no logging
    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }

    # Gzip compression
    gzip on;
    gzip_comp_level 2;
    gzip_min_length 1000;
    gzip_proxied expired no-cache no-store private auth;
    gzip_types text/plain application/javascript application/json text/xml text/css application/xml image/svg+xml;

    access_log off;
    client_max_body_size 50M;

    # SSL config (uncomment and configure for HTTPS)
    # listen 443 ssl;
    # ssl_certificate /etc/letsencrypt/live/#{domain}/fullchain.pem;
    # ssl_certificate_key /etc/letsencrypt/live/#{domain}/privkey.pem;
    # ssl_session_timeout 1d;
    # ssl_session_cache shared:SSL:50m;
}
    NGINX

    write_config(file, content)
  end

  def generate_nginx_passenger(app_name, domain)
    file = "#{SYSD_DIR}/nginx-passenger.conf"
    public_root = "#{Dir.pwd}/public"

    content = <<~NGINX
# Nginx with Passenger - Generated by: lux sysd generate
# App: #{app_name} | Domain: #{domain}
# Note: Passenger runs Ruby directly, no separate process needed
#
# Install:
#   sudo cp #{file} /etc/nginx/sites-available/#{app_name}
#   sudo ln -sf /etc/nginx/sites-available/#{app_name} /etc/nginx/sites-enabled/
#   sudo nginx -t && sudo systemctl reload nginx

#{SECURITY_FILTER_NGINX}
server {
    listen 80;
    server_name #{domain} *.#{domain};

    root #{public_root};

    # Block malicious requests
    if ($blocked_request) {
        return 404 "not found";
    }

    # Passenger config
    passenger_enabled on;
    passenger_ruby /usr/bin/ruby;
    passenger_app_env production;
    passenger_friendly_error_pages off;
    passenger_min_instances 1;

    # Assets with caching
    location ^~ /assets/ {
        gzip_static on;
        expires max;
        add_header Cache-Control public;
    }

    # Favicon - no logging
    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }

    # Gzip compression
    gzip on;
    gzip_comp_level 2;
    gzip_min_length 1000;
    gzip_proxied expired no-cache no-store private auth;
    gzip_types text/plain application/javascript application/json text/xml text/css application/xml image/svg+xml;

    access_log off;
    client_max_body_size 50M;

    # SSL config (uncomment and configure for HTTPS)
    # listen 443 ssl;
    # ssl_certificate /etc/letsencrypt/live/#{domain}/fullchain.pem;
    # ssl_certificate_key /etc/letsencrypt/live/#{domain}/privkey.pem;
    # ssl_session_timeout 1d;
    # ssl_session_cache shared:SSL:50m;
}
    NGINX

    write_config(file, content)
  end

  def write_config(file, content)
    if File.exist?(file) && File.read(file) == content
      puts "Skipped  #{file} (unchanged)"
      0
    else
      File.write(file, content)
      puts "Generated #{file}"
      1
    end
  end

  def load_dotenv
    return unless File.exist?('.env')

    File.readlines('.env').each do |line|
      line = line.strip
      next if line.empty? || line.start_with?('#')

      key, value = line.split('=', 2)
      ENV[key] = value if key && value
    end
  end

  def parse_ports(port_arg)
    if port_arg.to_s.include?('-')
      start_port, end_port = port_arg.split('-').map(&:to_i)
      (start_port..end_port).to_a
    else
      [port_arg.to_i]
    end
  end

  def sysd_list
    unless Dir.exist?(SYSD_DIR)
      puts "No service directory found at #{SYSD_DIR}".yellow
      puts "Run 'lux sysd generate' first"
      return
    end

    service_files = Dir.glob("#{SYSD_DIR}/*.service")

    if service_files.empty?
      puts "No service files found in #{SYSD_DIR}".yellow
      puts "Run 'lux sysd generate' first"
      return
    end

    puts "Services in #{SYSD_DIR}:".green
    puts

    service_files.each do |file|
      service_name = File.basename(file, '.service')
      status = get_service_status(service_name)
      puts "  #{service_name}: #{status}"
    end
  end

  def get_service_status(service_name)
    installed = system("systemctl list-unit-files #{service_name}.service &>/dev/null 2>&1")

    if installed
      status_output = `systemctl is-active #{service_name} 2>/dev/null`.strip
      case status_output
      when 'active' then 'running'.green
      when 'inactive' then 'stopped'.yellow
      when 'failed' then 'failed'.red
      else status_output
      end
    else
      'not installed'.gray
    end
  end

  def sysd_install(service)
    unless Dir.exist?(SYSD_DIR)
      puts "No service directory found at #{SYSD_DIR}".yellow
      puts "Run 'lux sysd generate' first"
      return
    end

    if service
      file = "#{SYSD_DIR}/#{service}.service"
      file = "#{SYSD_DIR}/lux-#{service}.service" unless File.exist?(file)

      unless File.exist?(file)
        puts "Service file not found: #{file}".red
        return
      end

      show_install_instructions(file)
    else
      # Show all install instructions
      Dir.glob("#{SYSD_DIR}/*.service").each do |file|
        show_install_instructions(file)
        puts
      end
    end
  end

  def show_install_instructions(file)
    puts "Install instructions for #{File.basename(file)}:".green
    puts

    # Extract header comments (install instructions)
    File.readlines(file).each do |line|
      break unless line.start_with?('#')
      puts "  #{line}"
    end
  end

  def sysd_action(action, service)
    unless service
      puts "Error: Service name required".red
      puts "Usage: lux sysd #{action} <service>"
      return
    end

    puts "#{action.capitalize}ing #{service}...".yellow
    system('sudo', 'systemctl', action, service)
    system('sudo', 'systemctl', 'status', service, '--no-pager') if action != 'stop'
  end

  def sysd_log(service)
    unless service
      puts "Error: Service name required".red
      puts "Usage: lux sysd log <service>"
      return
    end

    exec('sudo', 'journalctl', '-u', service, '-f', '-n', '100')
  end

  def sysd_status(service)
    if service
      system('sudo', 'systemctl', 'status', service, '--no-pager')
    else
      sysd_list
    end
  end

  def sysd_tui
    require 'tty-prompt'

    if Process.uid == 0
      puts "Don't run with sudo. Sudo is used internally for systemctl commands."
      exit 1
    end

    ServiceTUI.new.run
  end

  class ServiceTUI
    SYSTEM_SERVICES = {
      'nginx' => {
        name: 'Nginx',
        actions: %w[status start stop restart reload log]
      },
      'caddy' => {
        name: 'Caddy',
        actions: %w[status start stop restart reload log]
      },
      'postgresql' => {
        name: 'PostgreSQL',
        actions: %w[status start stop restart log],
        detect: %w[postgresql postgresql@16-main postgresql@15-main postgresql-16 postgresql-15]
      },
      'redis' => {
        name: 'Redis',
        actions: %w[status start stop restart log],
        detect: %w[redis redis-server]
      },
      'memcached' => {
        name: 'Memcached',
        actions: %w[status start stop restart log]
      }
    }

    def initialize
      @prompt = TTY::Prompt.new
      @service_map = {}
      @per_page = 12
    end

    def run
      loop do
        clear_screen
        services = available_services
        choice = @prompt.select("Select service:", services + ['Exit'], per_page: @per_page)
        break if choice == 'Exit'

        handle_service(choice)
      end
    end

    private

    def clear_screen
      system('clear') || system('cls')
    end

    def available_services
      services = []

      # Local lux services from ./config/sysd/
      if Dir.exist?(SYSD_DIR)
        Dir.glob("#{SYSD_DIR}/*.service").each do |file|
          name = File.basename(file, '.service')
          status = get_status(name)
          display = "#{name} [#{status}]"
          @service_map[display] = { service: name, config: { actions: %w[status start stop restart log install] } }
          services << display
        end
      end

      # System services
      SYSTEM_SERVICES.each do |key, config|
        if config[:detect]
          name = config[:detect].find { |n| service_exists?(n) }
          if name
            status = get_status(name)
            display = "#{config[:name]} (#{name}) [#{status}]"
            @service_map[display] = { service: name, config: config }
            services << display
          end
        elsif service_exists?(key)
          status = get_status(key)
          display = "#{config[:name]} [#{status}]"
          @service_map[display] = { service: key, config: config }
          services << display
        end
      end

      services
    end

    def service_exists?(name)
      system("systemctl list-unit-files #{name}.service &>/dev/null 2>&1")
    end

    def get_status(name)
      output = `systemctl is-active #{name} 2>/dev/null`.strip
      case output
      when 'active' then 'running'
      when 'inactive' then 'stopped'
      when 'failed' then 'failed'
      else 'unknown'
      end
    end

    def handle_service(display_name)
      info = @service_map[display_name]
      return unless info

      service = info[:service]
      config = info[:config]

      loop do
        clear_screen
        action = @prompt.select("#{service}:", config[:actions] + ['Back'], per_page: @per_page)
        break if action == 'Back'

        execute_action(service, action)
        @prompt.keypress("\nPress any key to continue...")
      end
    end

    def execute_action(service, action)
      case action
      when 'log'
        system('sudo', 'journalctl', '-u', service, '-n', '50', '--no-pager')
      when 'install'
        file = "#{SYSD_DIR}/#{service}.service"
        if File.exist?(file)
          puts "Install instructions:".green
          puts
          File.readlines(file).each do |line|
            break unless line.start_with?('#')
            puts "  #{line}"
          end
        else
          puts "Service file not found in #{SYSD_DIR}/".yellow
        end
      else
        system('sudo', 'systemctl', action, service)
      end
    end
  end
end
